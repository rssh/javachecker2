Checkers(
[
 define(StringInSwitch,coin,"string in switch",
        BT_TYPE_RULESET,
        ruleset(
          IfStatement(MethodCall($x,Identifier("equals"),
                                   Arguments([StringLiteral($y)])),
                      $block1,
           IfStatement(MethodCall($x,Identifier("equals"),
                                   Arguments([StringLiteral($z)])),
                      $block2,
                      $block3
                      ))
              -> true [ violationDiscovered(StringInSwitch,"string in switch",
                        x($block1,$block2,$block3)) ],

        # also String literals can be first in if-s
          IfStatement(MethodCall(StringLiteral($l1),Identifier("equals"),
                                                     Arguments([$x])),
                      $block1,
          IfStatement(MethodCall(StringLiteral($l2),Identifier("equals"),
                                                     Arguments([$x])),
                      $block2,
                      $block3
                     ))
              -> true [ violationDiscovered(StringInSwitch,"string in switch",
                        x($block1,$block2,$block3)) ]
        ),
        true
  ),

 define(AllIfs,coin,"all ifs",
        BT_TYPE_RULESET,
        ruleset(
          IfStatement($x,$y,$z)
                -> true [ violationDiscovered(AllIfs, "all ifs",$x) ]
         ),
         true
 ),

 define(AllCEs,coin,"all conditional expressions",
        BT_TYPE_RULESET,
        ruleset(
          ConditionalExpression($x,$y,$z)
             -> true [ violationDiscovered(AllCEs, "condition expression",
                          s($x,$y,$z)) ],
          $x [ x!=true ] -> true
         ),
         true
 ),
 
 

 define(InstanceOfSwitch,coin,"instanceof switch",
        FT_TYPE_RULESET,
        ruleset(
          IfStatement(InstanceOfExpression($x,$c1),
           $block1,
           IfStatement(InstanceOfExpression($x,$c2),
            $blok2,
            $block3
          ))
           -> true [ violationDiscovered(InstanceOfSwitch,
                         "instanceof switch",$block1) ]
         ),
         true
 ),

 define(ByteLiteral,coin,"byte literal",
        FT_TYPE_RULESET,
        ruleset(
         CastExpression(byte,IntegerLiteral($x)) -> true
                    [ violationDiscovered(ByteLiteral, "byte literal", $x) ],
         CastExpression(byte,CharacterLiteral($x)) -> true
                     [ violationDiscovered(ByteLiteral, "byte literal", $x) ]
        ),true),


 define(AllIntegerLiteral,coin,"all integer literals",
        FT_TYPE_RULESET,
        ruleset(
         IntegerLiteral($x) -> true
         [ violationDiscovered(AllIntegerLiteral, "all integer literals", $x) ]
        ),true),

 define(BigIntegerLiteral,coin,"big integer literals(undescores)",
        FT_TYPE_RULESET,
        ruleset(
         IntegerLiteral($x) 
           [ ($x > 100000) || ($x < -100000) ] -> true
                              [ violationDiscovered(BigIntegerLiteral, 
                                     "big integer literals(undescores)", $x) ]
                              !-> false
        ),true),


 define(MultiCatch,coin,"multi catch",
        FT_TYPE_RULESET,
        ruleset(
         cons(Catch($fp1,$block),cons(Catch($fp2,$block),$z)) -> true
                    [ violationDiscovered(MultiCatch, "multi catch", $fp1) ]
        ),true),

 define(AllCatchs,coin,"all catchs",
        FT_TYPE_RULESET,
        ruleset(
         cons(Catch($fp1,$block),$x) -> true
                    [ violationDiscovered(AllCatchs, "all catchs", $fp1) ]
        ),true),

 define(CatchInFinally,coin,"catch in finally",
        BT_TYPE_RULESET,
        ruleset(
         import(general,apply),
         TryStatement($block1,$catchs,$finally) -> FindCatch($finally),
         FindCatch($block) -> 
           CHECK(FindSubterm.find(Catch($a,$b),$block),$block),
         CHECK(false,$block) -> false,
         CHECK(true,$block) -> true
                    [  violationDiscovered(CatchInFinally,"catch in finally",
                                           $block) ]
        ),true),

 define(LoopWithRemove,coin,"loop with remove",
        BT_TYPE_RULESET,
        ruleset(
         import(general,apply),
         WhileStatement(
           MethodCall($x,Identifier("hasNext"),Arguments([])),
           $block
         ) -> FindRemove($x,$block) ,

         ForStatement(
            TraditionalForLoopHead($forinit, 
               MethodCall($x,Identifier("hasNext"),Arguments([])),
               NIL
            ), $block) -> FindRemove($x,$block), 

         FindRemove($x,$block) -> 
           CHECK(FindSubterm.find(
                   MethodCall($x,Identifier("remove"),Arguments([])),
                   $block),$block),
                       
           CHECK(false,$block) -> false,
           CHECK(true,$block) -> true
                    [  violationDiscovered(LoopWithRemove,"loop with remove",
                                           $block) ],

            p($x) -> $x [ println($x) ]

        ),true),



 define(ObjectSwitch,coin,"object switch",
        FT_TYPE_RULESET,
        ruleset(
          IfStatement(InstanceOfExpression($x,$c1),
           $block1,
           IfStatement(InstanceOfExpression($x,$c2),
            $blok2,
            $block3
          ))
           -> true [ violationDiscovered(ObjectSwitch,
                         "object switch",$block1) ],
          IfStatement(EqualityExpression($x,$op1,$c1),
           $block1,
           IfStatement(EqualityExpression($x,$op1,$c2),
            $blok2,
            $block3
          ))
           -> true [ violationDiscovered(ObjectSwitch,
                         "object switch",$block1) ],
          IfStatement(MethodCall($x,$method1,$args1),
           $block1,
           IfStatement(MethodCall($x,$method2,$args2),
            $blok2,
            $block3
          ))
           -> true [ violationDiscovered(ObjectSwitch,
                         "object switch",$block1) ]
         ),
         true
 ),

 define(RethrowClause,coin,"rethrow clause",
        FT_TYPE_RULESET,
        ruleset(
         Catch($fp1,Block([ThrowStatement($x)])) -> true
                 [ violationDiscovered(RethrowClause, "rethrow clause", $fp1) ]
        ),true),

 define(WideningSemantics,coin,"widening operator (semantics)",
        MODEL_RULESET,
        ruleset(
         import(general,apply),
         import(List,car),
         import(List,cdr),
         AndExpressionModel($x,IntegerLiteral(255),$ctx)
             [ $ctx.sameTypes(
               car($ctx.getExpressionModel().getSubExpressions()).getType(),
               $ctx.resolveTypeTerm(byte)) ]  -> true
            [ violationDiscovered(WideningSemantics, 
                              "widening operator (semantics)", $x) ]
                                              !-> false,
         AndExpressionModel(IntegerLiteral(255),$x,$ctx)
            [ $ctx.sameTypes(
                car(cdr($ctx.getExpressionModel().getSubExpressions()))
                                                                  .getType(),
                $ctx.resolveTypeTerm(byte)) ]  -> true
              [ violationDiscovered(WideningSemantics, 
                              "widening operator (semantics)", $x) ]
                                              !-> false
        ),true),


 define(AllBitAnds,coin,"all bit ands",
        BT_TYPE_RULESET,
        ruleset(
         AndExpression($x,$y) -> true 
              [ violationDiscovered(AllBitAnds, "all bit ands", A($x,$y)) ]
        ),true),

 define(ForsWithNext,coin,"for with limit like it.next()",
        BT_TYPE_RULESET,
        ruleset(
         ForStatement(
            TraditionalForLoopHead($forinit, 
               MethodCall($x,Identifier("hasNext"),Arguments([])),
               NIL
            ), $block) -> true
              [ violationDiscovered(ForsWithNext, 
                        "for loop, limited by it.next", A($x,$block)) ]
        ),true),
       
 define(AllTraditionalFors,coin,"all traditional fors",
        FT_TYPE_RULESET,
        ruleset(
         ForStatement(
            TraditionalForLoopHead($x, $y, $z),
            $block   )              ->  $block
              [ violationDiscovered(AllTraditionalFors, 
                                    "traditional for", A($x,$y,$z)) ]
        ),true),

 define(ForAroundSizeOrLength,coin,"for loop from 0 to size or length",
        FT_TYPE_RULESET,
        ruleset(
          
         # let LengthOrSize will be uniform 
         Name([$x,Identifier("length")]) -> LengthOrSize($x),
         FieldAccess([$x,Identifier("length")]) -> LengthOrSize($x),
         MethodCall($x,Identifier("size"),Arguments([])) -> LengthOrSize($x),

         # also PreIncrement and PostIncrement are same in ForUpdate statements
         StatementExpression(PreIncrementExpression($x)) -> Increment($x),
         StatementExpression($x,"++") -> Increment($x),

         ForInit(LocalVariableDeclaration($im,int,
                    [VariableDeclarator(
                       VariableDeclaratorId($index,0),
                        IntegerLiteral(0)
                     )]
                 )) -> ZeroForInit($index),

         ForInit(StatementExpressionList([
              StatementExpression($index,"=",IntegerLiteral(0))
                ])) -> ZeroForInit($index),


         ForStatement(
            TraditionalForLoopHead(
               ZeroForInit($index),
               RelationalExpression($index,"<",LengthOrSize($x)), 
               ForUpdate(StatementExpressionList(
                [Increment($index)]
               ))),
            $block   )              -> $block 
              [ violationDiscovered(ForAroundSizeOrLength, 
                          "for loop from 0 to size or length()",
                          s($index,$block)) ]

        ),true)

]

);

