Checkers(
[
 define(StringInSwitch,coin,"string in switch",
        BT_TYPE_RULESET,
        ruleset(
          IfStatement(MethodCall($x,Identifier("equals"),
                                   Arguments([StringLiteral($y)])),
                      $block1,
           IfStatement(MethodCall($x,Identifier("equals"),
                                   Arguments([StringLiteral($z)])),
                      $block2,
                      $block3
                      ))
              -> true [ violationDiscovered(StringInSwitch,"string in switch",
                        x($block1,$block2,$block3)) ],

        # also String literals can be first in if-s
          IfStatement(MethodCall(StringLiteral($l1),Identifier("equals"),
                                                     Arguments([$x])),
                      $block1,
          IfStatement(MethodCall(StringLiteral($l2),Identifier("equals"),
                                                     Arguments([$x])),
                      $block2,
                      $block3
                     ))
              -> true [ violationDiscovered(StringInSwitch,"string in switch",
                        x($block1,$block2,$block3)) ]
        ),
        true
  ),

 define(AllIfs,coin,"all ifs",
        BT_TYPE_RULESET,
        ruleset(
          IfStatement($x,$y,$z)
                -> true [ violationDiscovered(AllIfs, "all ifs",$x) ]
         ),
         true
 ),
 

 define(InstanceOfSwitch,coin,"instanceof switch",
        FT_TYPE_RULESET,
        ruleset(
          IfStatement(InstanceOfExpression($x,$c1),
           $block1,
           IfStatement(InstanceOfExpression($x,$c2),
            $blok2,
            $block3
          ))
           -> true [ violationDiscovered(InstanceOfSwitch,
                         "instanceof switch",$block1) ]
         ),
         true
 ),

 define(ByteLiteral,coin,"byte literal",
        FT_TYPE_RULESET,
        ruleset(
         CastExpression(byte,IntegerLiteral($x)) -> true
                    [ violationDiscovered(ByteLiteral, "byte literal", $x) ],
         CastExpression(byte,CharacterLiteral($x)) -> true
                     [ violationDiscovered(ByteLiteral, "byte literal", $x) ]
        ),true),


 define(AllIntegerLiteral,coin,"all integer literals",
        FT_TYPE_RULESET,
        ruleset(
         IntegerLiteral($x) -> true
         [ violationDiscovered(AllIntegerLiteral, "all integer literals", $x) ]
        ),true),

 define(BigIntegerLiteral,coin,"big integer literals(undescores)",
        FT_TYPE_RULESET,
        ruleset(
         IntegerLiteral($x) 
           [ ($x > 100000) || ($x < -100000) ] -> true
                              [ violationDiscovered(BigIntegerLiteral, 
                                     "big integer literals(undescores)", $x) ]
                              !-> false
        ),true),


 define(MultiCatch,coin,"multi catch",
        FT_TYPE_RULESET,
        ruleset(
         cons(Catch($fp1,$block),cons(Catch($fp2,$block),$z)) -> true
                    [ violationDiscovered(MultiCatch, "multi catch", $fp1) ]
        ),true),

 define(AllCatchs,coin,"all catchs",
        FT_TYPE_RULESET,
        ruleset(
         cons(Catch($fp1,$block),$x) -> true
                    [ violationDiscovered(AllCatchs, "all catchs", $fp1) ]
        ),true),

 define(CatchInFinally,coin,"catch in finally",
        BT_TYPE_RULESET,
        ruleset(
         import(general,apply),
         TryStatement($block1,$catchs,$finally) -> FindCatch($finally),
         FindCatch($block) -> 
           CHECK(FindSubterm.find(Catch($a,$b),$block),$block),
         CHECK(false,$block) -> false,
         CHECK(true,$block) -> true
                    [  violationDiscovered(CatchInFinally,"catch in finally",
                                           $block) ]
        ),true),

 define(Elvis,coin,"elvis",
        BT_TYPE_RULESET,
        ruleset(
          ConditionalExpression(
           EqualityExpression($x,"==",NullLiteral()), 
                 $ifNull,  MethodCall($x,$method,$args)) -> true
                 [ violationDiscovered(Elvis, "elvis", $method) ],
          ConditionalExpression(
           EqualityExpression($x,"!=",NullLiteral()), 
                 MethodCall($x,$method,$args), $ifNull) -> true
                 [ violationDiscovered(Elvis, "elvis", $method) ],
          ConditionalExpression(
           EqualityExpression(NullLiteral(),"!=",$x), 
                 MethodCall($x,$method,$args), $ifNull) -> true
                 [ violationDiscovered(Elvis, "elvis", $method) ],
          ConditionalExpression(
           EqualityExpression(NullLiteral(),"==",$x), 
                 MethodCall($x,$method,$args), $ifNull) -> true
                 [ violationDiscovered(Elvis, "elvis", $method) ]
        ),true),

 define(LoopWithRemove,coin,"loop with remove",
        BT_TYPE_RULESET,
        ruleset(
         import(general,apply),
         WhileStatement(
           MethodCall($x,Identifier("hasNext"),Arguments([])),
           $block
         ) -> FindRemove($x,$block) ,

         FindRemove($x,$block) -> 
           CHECK(FindSubterm.find(
                   MethodCall($x,Identifier("remove"),Arguments([])),
                   $block),$block),
                       
           CHECK(false,$block) -> false,
           CHECK(true,$block) -> true
                    [  violationDiscovered(LoopWithRemove,"loop with remove",
                                           $block) ],

            p($x) -> $x [ println($x) ]

        ),true),

 define(ObjectSwitch,coin,"object switch",
        FT_TYPE_RULESET,
        ruleset(
          IfStatement(InstanceOfExpression($x,$c1),
           $block1,
           IfStatement(InstanceOfExpression($x,$c2),
            $blok2,
            $block3
          ))
           -> true [ violationDiscovered(ObjectSwitch,
                         "object switch",$block1) ],
          IfStatement(EqualityExpression($x,$op1,$c1),
           $block1,
           IfStatement(EqualityExpression($x,$op1,$c2),
            $blok2,
            $block3
          ))
           -> true [ violationDiscovered(ObjectSwitch,
                         "object switch",$block1) ],
          IfStatement(MethodCall($x,$method1,$args1),
           $block1,
           IfStatement(MethodCall($x,$method2,$args2),
            $blok2,
            $block3
          ))
           -> true [ violationDiscovered(ObjectSwitch,
                         "object switch",$block1) ]
         ),
         true
 ),

 define(RethrowClause,coin,"rethrow clause",
        FT_TYPE_RULESET,
        ruleset(
         Catch($fp1,Block([ThrowStatement($x)])) -> true
                 [ violationDiscovered(RethrowClause, "rethrow clause", $fp1) ]
        ),true),

 define(WideningSyntax,coin,"widening operator (syntax)",
        BT_TYPE_RULESET,
        ruleset(
         AndExpression($x,IntegerLiteral(255)) -> true
              [ violationDiscovered(WideningSyntax, "widening operator (syntax)", $x) ],
         AndExpression(IntegerLiteral(255),$x) -> true
              [ violationDiscovered(WideningSyntax, "widening operator (syntax)", $x) ]
        ),true),

             #  $ctx.getExpressionModel().getSubExpressions().get(0).getType(),

 define(WideningSemantics,coin,"widening operator (semantics)",
        MODEL_RULESET,
        ruleset(
         import(general,apply),
         import(List,car),
         import(List,cdr),
         AndExpressionModel($x,IntegerLiteral(255),$ctx)
             [ $ctx.sameTypes(
               car($ctx.getExpressionModel().getSubExpressions()).getType(),
               $ctx.resolveTypeTerm(byte)) ]  -> true
            [ violationDiscovered(WideningSemantics, 
                              "widening operator (semantics)", $x) ]
                                              !-> false,
         AndExpressionModel(IntegerLiteral(255),$x,$ctx)
            [ $ctx.sameTypes(
                car(cdr($ctx.getExpressionModel().getSubExpressions()))
                                                                  .getType(),
                $ctx.resolveTypeTerm(byte)) ]  -> true
              [ violationDiscovered(WideningSemantics, 
                              "widening operator (semantics)", $x) ]
                                              !-> false
        ),true),


 define(AllBitAnds,coin,"all bit ands",
        BT_TYPE_RULESET,
        ruleset(
         AndExpression($x,$y) -> true 
              [ violationDiscovered(AllBitAnds, "all bit ands", A($x,$y)) ]
        ),true)
 
]

);

