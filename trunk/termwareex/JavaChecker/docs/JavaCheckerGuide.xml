<?xml version="1.0" encoding="KOI8-R"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" 
                     "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
>
<article>
  <artheader>
  <title>JavaChecker guide </title>
  <author>
      <firstname>Ruslan</firstname>
      <surname>Shevchenko</surname>
  <affilation>
    <orgname>Grad-Soft Ltd</orgname>
    <address>
      <city> Kiev </city>
      <city> Ukraine </city>
      <email> info@gradsoft.kiev.ua </email>
    </address>
  </affilation>

  </author>
  </artheader>
  <abstract>
    <para>
     JavaChecker is a static analyzer tool for java language, based on TermWare
   technology. It is development by <ulink url="http://www.gradsoft.kiev.ua" > Grad-Soft Ltd </ulink>, Kiev,
   Ukraine.
   </para>
  </abstract>
  <sect1>
    <title> Invoking </title>
    <para>
<cmdsynopsis>
  <command>JavaChecker.bat</command>
 <arg> options </arg> 
 <arg choice="plain"> directory </arg>  
</cmdsynopsis>
   JavaChecker is process all <code>*.java</code> files in target directory and all
 subdirectories of one.
Options have next meaning:
<screen>
  --prefs fname              read configuration from preferences file fname.
  --showFiles                during check, print names of analyzed files.
  --maxFiles N               set maximum number of loaded files at one time to N
  --help                     output this help message.
  --q                        minimize output to stdout
  --output fname             write report to file fname
  --debug                    put to stderr a lot of debug output
  --dump                     dump to stdout AST of parsed files
</screen>  
    </para>
  </sect1>
  <sect1>
    <title> Configuration of checks </title>
    <para>
    JavaChecker is configurated via properties file. Example of such file can
    be found in <filename>etc</filename> subdirectory of JavaChecker distribution,
 or cited here:
<programlisting>
<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE preferences SYSTEM "http://java.sun.com/dtd/preferences.dtd">
<preferences>
<root type="user">
 <map />
 <node name="ua" >
  <map />
  <node name="kiev" >
  <map />
    <node name="gradsoft" >
    <map />
      <node name="JavaChecker" >
       <map>
         <!-- JavaChecker config file for properties -->
         <!-- usage: JavaChecker -prefs <this-file>  -->
         <entry key="CheckEmptyCatchClauses" value="true" />
         <entry key="CheckGenericExceptionCatchClauses" value="true" />
         <entry key="CheckGenericExceptionSpecifications" value="true" />
         <entry key="CheckOverloadedEquals" value="true" />
         <entry key="CheckSynchronizeViolations" value="true" />
         <entry key="CheckVariablePatterns" value="true" />
         <entry key="NonFinalFieldNamePattern" value="[a-z].*_" />
         <entry key="FinalFieldNamePattern" value="[A-Z]([A-Z]|[0-9]|_)*" />
         <entry key="CheckClassNamePatterns" value="true" />
         <entry key="ClassNamePattern" value="[A-Z].*" />
         <entry key="CheckMethodNamePatterns" value="true" />
         <entry key="MethodNamePattern" value="[a-z].*" />
         <entry key="CheckNonFinalPublicFields" value="true" />
         <entry key="CheckHiding" value="true" />
       </map>
    </node>
   </node>
  </node>
 </node> 
</root>
</preferences>
]]>
</programlisting>

    </para>
  </sect1>
  <sect1>
    <title> Checks </title>
    <sect2> 
      <title> Exception Handling </title>
    </sect2>
    <sect3>
      <title> Empty catch clause </title>
      <para>
         This check report about empty catch clauses.
         It is configurated by boolean property <code> CheckEmptyCatchClauses </code>.
         Code example:
<programlisting>
        try {
          InputStream input = new FileInputStream(f);
          input.close();
        }catch(IOException ex){
            /* ignore - this must be catched */
        }
</programlisting>
      </para>
    </sect3>
    <sect3>
      <title> Catch of generic exception </title>
      <para>
         This check report about generic exception catch.
         Configurated by <code> CheckGenericExceptionCathClauses </code>.
         Code example:
<programlisting>
        try {
          InputStream input = new FileInputStream(f);
          input.close();
        }catch(Exception ex){
           System.err.println(ex.getMessage());
        }
</programlisting>
      </para>
    </sect3>
    <sect3>
      <title> method throws generic exception </title>
      <para>
        Reports, when we see generic exception in <code> throws </code> clause of method declararion.
        Configurated by <code> CheckGenericExceptionSpecifications </code> property.
<programlisting>
public class JET2 {
    

    public static void doSomething() throws Exception
    {
      doSomethingElse();
    }
    
    
}
</programlisting>
      </para>
    </sect3>
    <sect2>
     <title> Contracts violation </title>
    </sect2>
    <sect3>
     <title> equals/hashcode contracts </title>
     <para>
       This rule report about violation of hashcode/equals contract: when we overload equals we must
 overload hashcode and vice-versa. Configurarion property is <code> CheckOverloadedEquals </code>.
 Example of such situation:
<programlisting>
public class Ce
{

 public boolean equals(Object o)
   { return (o instanceof Ce); }


}
</programlisting>
     </para>
    </sect3>
    <sect2>
     <title> Multithreading </title>
    </sect2>
     <sect3>
       <title> Unsynchronized access for synchronized variable </title>
       <para> 
          This rule report about unsynchronized access to member variables
   with synchronized setter. It is configured by <code> CheckSynchronizeViolations </code>
   boolean property. Example:
<programlisting>
package testpackages.sv;


public class Sv1
{

  public synchronized void setMyVariable(int x)
  {
   myVariable_=x;
  }

  public void incrementMyVariable()
  {
   ++myVariable_;
  }

  private int myVariable_=0;
}
</programlisting>
        Note, that checker assume, that we have no hiding defects in code. (i. e.
  that we have no formal parameter or local variable, with name same as name of field).
       </para>
     </sect3>
    <sect2>
     <title> Style </title>
    <sect3>
       <title> Naming </title>
       <para>
           JavaChecker can perform checking of identifiers, which based on role of identifier and 
             regexp pattern for this roles.
          <itemizedlist>
            <listitem>
            <para>  patterns of variables. enabled by property  <code> CheckVariablePatterns </code>
             and use next pattterns.
              <itemizedlist>
                <listitem><simpara>
                  <code> NonFinalFieldNamePattern </code> - set pattern for non-final fields. default is <code> [a-z].* </code>
                </simpara></listitem>
                <listitem><simpara>
                  <code> FinalFieldNamePattern </code> - set pattern for final fields. default is <code> [A-Z](A-Z|_|0-9)* </code>
                </simpara></listitem>
              </itemizedlist>
              Names of patterns are names of appropriative property, so you can confgigure this
              patterns via JavaChecker properties file.
            </para>
            </listitem>
            <listitem><para>
               CheckClassNamePatterns property enable checking of class names for <code> ClassNamePattern </code>.
                Default is <code> [A-Z].* </code>
            </para></listitem>
            <listitem><para>
               CheckMethodNamePatterns property enable checking of method names for pattern <code> MethodNamePattern </code>.
                Default is <code> [A-Z].* </code>
            </para></listitem>
          </itemizedlist>
       </para>
    </sect3>
    <sect3>
      <title> Empty package declarations </title>
      <para> This is enabled by property <code> CheckPackageDeclarations </code>. </para>
    </sect3>
    <sect3>
       <title> Using public variables </title>
       <para> Report about non-final public field. It is configurated by property
        CheckNonFinalPublicFields.
<programlisting>
public class X
{
 public int myPublicVar;
}
</programlisting>
        </para>
    </sect3>
    <sect3>
     <title> Hiding defects. </title>
    </sect3>
     This checks are enabled by boolean property <code> CheckHiding </code>. When this property
is enabled, than JavaChecker reports about hiding defects: where some local variable or formal
parameter hide class field, as in next example:
<programlisting>
public class X
{
 void p(int x)
 {
   System.out.println(""+x);
 }

 public int x;
}
</programlisting>
     where formal parameter <code> x </code> hide field name <code> x </code>
    </sect2>
  </sect1>
  <sect1>
    <title> JavaChecker comments </title>
    <sect2>
     <title> Special comments </title>
     <para> It is possible to pass information to JavaChecker from source code via special comments.
      Such comments must be situated before class and package declarations and must look as follows:
 <code>!@checker:checker statement!@ </code>.
       For now JavaChecker understand only one checker statement: <code> disable(All) </code> as in next example:
<programlisting>
<![CDATA[
/**
 * Point class.
 *<pre>
 *@!checker:disable(All)!@
 *</pre>
 */
public class Point
{
 public int x;
 public int y;
}
]]>
</programlisting>
       Set of special comments will be extendend in future versions.
     </para>
    </sect2>
    <sect2>
     <title> JavaCC anb BYACC markers </title>
     <para>
       Also JavaChecker skip all checks for files, generated by JavaCC and BYACC.
   For determination of such files JavaChecker search next markers in source code:
    <itemizedlist>
     <listitem><simpara>
        <code> Generated By:JavaCC: Do not edit this line.  </code>
     </simpara></listitem>
     <listitem><simpara>
         <code> Generated by Byacc </code>
     </simpara></listitem>
     <listitem><simpara>
         <code> This file created by BYACC" </code>
     </simpara></listitem>
    </itemizedlist>
     </para>
    </sect2>
  </sect1>
  <sect1>
    <title>  Integrating with ant </title>
    <para>
      JavaChecker can be integrated with apacha ant build tool. Just add next task definition to you build.xml file:
<programlisting>
<![CDATA[
    <taskdef name="javachecker"  classname="ua.kiev.gradsoft.JavaChecker.ant.JavaCheckerTask">
     <classpath>
      <pathelement location="${jchhome}/jlib/JavaChecker.jar"/>
      <pathelement location="${jchhome}/jlib/TermWare.jar"/>
     </classpath>

]]>
</programlisting>
      where <code> ${jchhome} </code> is a property which point to directory where JavaChecker is installed.
    </para>
    <para>
     Then you can use ant task <code> javachecker </code> with following attributes:
     <itemizedlist>
       <listitem><simpara>
          jchhome - required, must be set to directory, where javachecker is installed.
       </simpara></listitem>
       <listitem><simpara>
          input - required, must be set to directory, where located java files, which you want to check.
       </simpara></listitem>
       <listitem><simpara>
          input - required, must be set to directory, where located java files, which you want to check.
       </simpara></listitem>
       <listitem><simpara>
          output - optional, must be set to filename, where report will be printed. Otherwise, report will be
          printed to stdout.
       </simpara></listitem> 
       <listitem><simpara>
          prefs - optional, must be set to xml prefernces file with JavaChecker configuration.
       </simpara></listitem>
       <listitem><simpara>
          showfiles - optional, analog of <code> --showFiles </code> option  
       </simpara></listitem>
       <listitem><simpara>
          q - optional, analog of <code> -q </code> option.
       </simpara></listitem>
     </itemizedlist>
    </para>
    <para>
    Example:
<programlisting>
<![CDATA[
   <target name="check" depend="build" >
     <JavaChecker jchhome="${jchhome}" input="jsrc" output="jchreport.txt" prefs="etc/jchprefs.xml" />
   </target>
]]>
</programlisting>
    </para>
  </sect1>
</article>
